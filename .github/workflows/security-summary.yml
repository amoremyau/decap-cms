name: Security Summary

on:
  # Запускать ТОЛЬКО после окончания Security Gateway
  workflow_run:
    workflows: ["Security Gateway"]
    types: [completed]

  # Ручной запуск из Actions (удобно для тестов)
  workflow_dispatch:

permissions:
  actions: read
  checks: read
  contents: read
  pull-requests: write   # пишем комментарий в PR
  issues: write   

concurrency:
  # один прогон на один и тот же коммит
  group: security-summary-${{ github.event.workflow_run.head_sha || github.sha }}
  cancel-in-progress: true

jobs:
  summarize:
    # бежим только если Gateway завершился УСПЕШНО
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    steps:
      - name: Build summary & comment to PR
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            // SHA того же коммита, по которому бежали все проверки
            const sha = context.payload.workflow_run.head_sha;

            // Какие проверки сводим в таблицу
            const required = [
              "SAST - CodeQL",
              "SAST - Semgrep",
              "Lint - ESLint",
              "Dependency Audit",
              "Secrets Scan - Gitleaks",
              "DAST - OWASP ZAP Baseline",
              "Lint - GitHub Actions",
              "CI - Build & Test",
              "Security Gateway"
            ];

            // 1) Собираем последние статусы именно по этому SHA
            const { data } = await github.rest.actions.listWorkflowRunsForRepo({
              owner, repo, per_page: 100, head_sha: sha
            });

            const latest = {};
            for (const r of data.workflow_runs) {
              if (!required.includes(r.name)) continue;
              if (!latest[r.name]) latest[r.name] = r.conclusion; // первый — самый свежий
            }

            // 2) Таблица
            const rows = required.map(n => `| ${n} | ${latest[n] ?? "—"} |`).join("\n");
            const body = [
              "### Security Summary",
              "",
              "| Проверка | Статус |",
              "|---|---|",
              rows
            ].join("\n");

            // 3) НАДЕЖНЫЙ поиск PR: сначала по коммиту, затем резервный — среди открытых PR
            let prNumber = context.payload.workflow_run?.pull_requests?.[0]?.number;

            if (!prNumber) {
              // \u2014 официальное API для связи коммита с PR
              const prsBySha = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                owner, repo, commit_sha: sha
              });
              prNumber = prsBySha.data[0]?.number;
            }

            if (!prNumber) {
              // \u2014 резерв: просканировать открытые PR и сравнить head.sha
              const openPRs = await github.paginate(
                github.rest.pulls.list,
                { owner, repo, state: "open", per_page: 100 }
              );
              const hit = openPRs.find(p => p.head?.sha === sha);
              prNumber = hit?.number;
            }

            if (prNumber) {
              await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body });
              core.notice(`Summary posted to PR #${prNumber}`);
            } else {
              core.warning("PR not found for this commit; printing table to logs only.");
              console.log(body);
            }