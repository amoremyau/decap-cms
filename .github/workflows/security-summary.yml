name: Security Summary

on:
  # Запускать ТОЛЬКО после окончания Security Gateway
  workflow_run:
    workflows: ["Security Gateway"]
    types: [completed]

  # Ручной запуск из Actions (удобно для тестов)
  workflow_dispatch:

permissions:
  actions: read
  checks: read
  contents: read
  pull-requests: write   # пишем комментарий в PR

concurrency:
  # один прогон на один и тот же коммит
  group: security-summary-${{ github.event.workflow_run.head_sha || github.sha }}
  cancel-in-progress: true

jobs:
  summarize:
    # для workflow_run бежим только если Gateway завершился УСПЕШНО.
    # для ручного запуска (workflow_dispatch) — позволяем запускаться всегда.
    if: github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success'
    runs-on: ubuntu-latest

    steps:
      - name: Build summary table & comment to PR
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            // SHA коммита, который проверяли
            const sha =
              context.eventName === 'workflow_run'
                ? context.payload.workflow_run.head_sha
                : (context.payload.pull_request?.head?.sha || context.sha);

            const required = [
              "SAST - CodeQL",
              "SAST - Semgrep",
              "Lint - ESLint",
              "Dependency Audit",
              "Secrets Scan - Gitleaks",
              "DAST - OWASP ZAP Baseline",
              "Lint - GitHub Actions",
              "CI - Build & Test",
              "Security Gateway"
            ];

            // Берём последние статусы именно для этого SHA
            const { data } = await github.rest.actions.listWorkflowRunsForRepo({
              owner, repo, per_page: 100, head_sha: sha
            });

            const latest = {};
            for (const r of data.workflow_runs) {
              if (!required.includes(r.name)) continue;
              if (!latest[r.name]) latest[r.name] = r.conclusion; // первый — самый свежий
            }

            const rows = required.map(n => `| ${n} | ${latest[n] ?? "—"} |`).join("\n");
            const body = `### Security Summary

            | Проверка | Статус |
            |---|---|
            ${rows}
            `;

            // ---------- НАДЁЖНЫЙ ПОИСК PR ----------
            // 1) из payload (если повезёт)
            let prNumber =
              context.eventName === 'pull_request'
                ? context.payload.number
                : (context.payload.workflow_run?.pull_requests?.[0]?.number);

            // 2) по SHA
            if (!prNumber) {
              const prsBySha = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                owner, repo, commit_sha: sha
              });
              prNumber = prsBySha.data?.[0]?.number;
            }

            // 3) по head-ветке из workflow_run
            if (!prNumber && context.eventName === 'workflow_run') {
              const headBranch = context.payload.workflow_run.head_branch;
              const prsByHead = await github.rest.pulls.list({
                owner, repo, state: "open", head: `${owner}:${headBranch}`
              });
              prNumber = prsByHead.data?.[0]?.number;
            }

            if (prNumber) {
              await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body });
              core.info(`Summary posted to PR #${prNumber}`);
            } else {
              core.warning("PR not found for this run; printing summary to logs.");
              console.log(body);
            }
